/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DOCUMENT } from '@angular/common';
import { HttpBackend, HttpClient } from '@angular/common/http';
import { Inject, Optional, RendererFactory2, SecurityContext } from '@angular/core';
import { DomSanitizer } from '@angular/platform-browser';
import { of as rxof, Observable, Subject } from 'rxjs';
import { catchError, filter, finalize, map, share, take, tap } from 'rxjs/operators';
import { cloneSVG, getIconDefinitionFromAbbr, getNameAndNamespace, getSecondaryColor, hasNamespace, isIconDefinition, replaceFillColor, warn, withSuffix, withSuffixAndColor } from '../utils';
import { DynamicLoadingTimeoutError, HttpModuleNotImport, IconNotFoundError, NameSpaceIsNotSpecifyError, SVGTagNotFoundError, UrlNotSafeError } from './icon.error';
/** @type {?} */
const JSONP_HANDLER_NAME = '__ant_icon_load';
export class IconService {
    /**
     * @param {?} _rendererFactory
     * @param {?} _handler
     * @param {?} _document
     * @param {?} sanitizer
     */
    constructor(_rendererFactory, _handler, _document, sanitizer) {
        this._rendererFactory = _rendererFactory;
        this._handler = _handler;
        this._document = _document;
        this.sanitizer = sanitizer;
        this.defaultTheme = 'outline';
        /**
         * All icon definitions would be registered here.
         */
        this._svgDefinitions = new Map();
        /**
         * Cache all rendered icons. Icons are identified by name, theme,
         * and for twotone icons, primary color and secondary color.
         */
        this._svgRenderedDefinitions = new Map();
        this._inProgressFetches = new Map();
        /**
         * Url prefix for fetching inline SVG by dynamic importing.
         */
        this._assetsUrlRoot = '';
        this._twoToneColorPalette = {
            primaryColor: '#333333',
            secondaryColor: '#E6E6E6'
        };
        /**
         * Record if a handler is registered.
         */
        this._enableJsonpLoading = false;
        this._jsonpIconLoad$ = new Subject();
        this._renderer = this._rendererFactory.createRenderer(null, null);
        if (this._handler) {
            this._http = new HttpClient(this._handler);
        }
    }
    /**
     * @param {?} __0
     * @return {?}
     */
    set twoToneColor({ primaryColor, secondaryColor }) {
        this._twoToneColorPalette.primaryColor = primaryColor;
        this._twoToneColorPalette.secondaryColor =
            secondaryColor || getSecondaryColor(primaryColor);
    }
    /**
     * @return {?}
     */
    get twoToneColor() {
        // Make a copy to avoid unexpected changes.
        return (/** @type {?} */ (Object.assign({}, this._twoToneColorPalette)));
    }
    /**
     * Call this method to switch to jsonp like loading.
     * @return {?}
     */
    useJsonpLoading() {
        if (!this._enableJsonpLoading) {
            this._enableJsonpLoading = true;
            window[JSONP_HANDLER_NAME] = (/**
             * @param {?} icon
             * @return {?}
             */
            (icon) => {
                this._jsonpIconLoad$.next(icon);
            });
        }
        else {
            warn('You are already using jsonp loading.');
        }
    }
    /**
     * Change the prefix of the inline svg resources, so they could be deployed elsewhere, like CDN.
     * @param {?} prefix
     * @return {?}
     */
    changeAssetsSource(prefix) {
        this._assetsUrlRoot = prefix.endsWith('/') ? prefix : prefix + '/';
    }
    /**
     * Add icons provided by ant design.
     * @param {...?} icons
     * @return {?}
     */
    addIcon(...icons) {
        icons.forEach((/**
         * @param {?} icon
         * @return {?}
         */
        icon => {
            this._svgDefinitions.set(withSuffix(icon.name, icon.theme), icon);
        }));
    }
    /**
     * Register an icon. Namespace is required.
     * @param {?} type
     * @param {?} literal
     * @return {?}
     */
    addIconLiteral(type, literal) {
        const [name, namespace] = getNameAndNamespace(type);
        if (!namespace) {
            throw NameSpaceIsNotSpecifyError();
        }
        this.addIcon({ name: type, icon: literal });
    }
    /**
     * Remove all cache.
     * @return {?}
     */
    clear() {
        this._svgDefinitions.clear();
        this._svgRenderedDefinitions.clear();
    }
    /**
     * Get a rendered `SVGElement`.
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    getRenderedContent(icon, twoToneColor) {
        // If `icon` is a `IconDefinition`, go to the next step. If not, try to fetch it from cache.
        /** @type {?} */
        const definitionOrNull = isIconDefinition(icon)
            ? ((/** @type {?} */ (icon)))
            : this._svgDefinitions.get(icon) || null;
        // If `icon` is a `IconDefinition` of successfully fetch, wrap it in an `Observable`.
        // Otherwise try to fetch it from remote.
        /** @type {?} */
        const $iconDefinition = definitionOrNull
            ? rxof(definitionOrNull)
            : this._loadIconDynamically((/** @type {?} */ (icon)));
        // If finally get an `IconDefinition`, render and return it. Otherwise throw an error.
        return $iconDefinition.pipe(map((/**
         * @param {?} i
         * @return {?}
         */
        i => {
            if (!i) {
                throw IconNotFoundError((/** @type {?} */ (icon)));
            }
            return this._loadSVGFromCacheOrCreateNew(i, twoToneColor);
        })));
    }
    /**
     * @return {?}
     */
    getCachedIcons() {
        return this._svgDefinitions;
    }
    /**
     * Get raw svg and assemble a `IconDefinition` object.
     * @protected
     * @param {?} type
     * @return {?}
     */
    _loadIconDynamically(type) {
        // If developer doesn't provide HTTP module nor enable jsonp loading, just throw an error.
        if (!this._http && !this._enableJsonpLoading) {
            return rxof(HttpModuleNotImport());
        }
        // If multi directive ask for the same icon at the same time,
        // request should only be fired once.
        /** @type {?} */
        let inProgress = this._inProgressFetches.get(type);
        if (!inProgress) {
            const [name, namespace] = getNameAndNamespace(type);
            // If the string has a namespace within, create a simple `IconDefinition`.
            /** @type {?} */
            const icon = namespace
                ? { name: type, icon: '' }
                : getIconDefinitionFromAbbr(name);
            /** @type {?} */
            const suffix = this.useJsonpLoading ? '.js' : '.svg';
            /** @type {?} */
            const url = (namespace
                ? `${this._assetsUrlRoot}assets/${namespace}/${name}`
                : `${this._assetsUrlRoot}assets/${icon.theme}/${icon.name}`) + suffix;
            /** @type {?} */
            const safeUrl = this.sanitizer.sanitize(SecurityContext.URL, url);
            if (!safeUrl) {
                throw UrlNotSafeError(url);
            }
            /** @type {?} */
            const source = !this._enableJsonpLoading
                ? this._http
                    .get(safeUrl, { responseType: 'text' })
                    .pipe(map((/**
                 * @param {?} literal
                 * @return {?}
                 */
                literal => (Object.assign({}, icon, { icon: literal })))))
                : this._loadIconDynamicallyWithJsonp(icon, safeUrl);
            inProgress = source.pipe(tap((/**
             * @param {?} definition
             * @return {?}
             */
            definition => this.addIcon(definition))), finalize((/**
             * @return {?}
             */
            () => this._inProgressFetches.delete(type))), catchError((/**
             * @return {?}
             */
            () => rxof(null))), share());
            this._inProgressFetches.set(type, inProgress);
        }
        return inProgress;
    }
    /**
     * @protected
     * @param {?} icon
     * @param {?} url
     * @return {?}
     */
    _loadIconDynamicallyWithJsonp(icon, url) {
        return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        subscriber => {
            /** @type {?} */
            const loader = this._document.createElement('script');
            /** @type {?} */
            const timer = setTimeout((/**
             * @return {?}
             */
            () => {
                clean();
                subscriber.error(DynamicLoadingTimeoutError());
            }), 6000);
            loader.src = url;
            /**
             * @return {?}
             */
            function clean() {
                loader.parentNode.removeChild(loader);
                clearTimeout(timer);
            }
            this._document.body.appendChild(loader);
            this._jsonpIconLoad$
                .pipe(filter((/**
             * @param {?} i
             * @return {?}
             */
            i => i.name === icon.name && i.theme === icon.theme)), take(1))
                .subscribe((/**
             * @param {?} i
             * @return {?}
             */
            i => {
                subscriber.next(i);
                clean();
            }));
        }));
    }
    /**
     * Render a new `SVGElement` for a given `IconDefinition`, or make a copy from cache.
     * @protected
     * @param {?} icon
     * @param {?=} twoToneColor
     * @return {?}
     */
    _loadSVGFromCacheOrCreateNew(icon, twoToneColor) {
        /** @type {?} */
        let svg;
        /** @type {?} */
        const pri = twoToneColor || this._twoToneColorPalette.primaryColor;
        /** @type {?} */
        const sec = getSecondaryColor(pri) || this._twoToneColorPalette.secondaryColor;
        /** @type {?} */
        const key = icon.theme === 'twotone'
            ? withSuffixAndColor(icon.name, icon.theme, pri, sec)
            : icon.theme === undefined
                ? icon.name
                : withSuffix(icon.name, icon.theme);
        // Try to make a copy from cache.
        /** @type {?} */
        const cached = this._svgRenderedDefinitions.get(key);
        if (cached) {
            svg = cached.icon;
        }
        else {
            svg = this._setSVGAttribute(this._colorizeSVGIcon(
            // Icons provided by ant design should be refined to remove preset colors.
            this._createSVGElementFromString(hasNamespace(icon.name) ? icon.icon : replaceFillColor(icon.icon)), icon.theme === 'twotone', pri, sec));
            // Cache it.
            this._svgRenderedDefinitions.set(key, (/** @type {?} */ (Object.assign({}, icon, { icon: svg }))));
        }
        return cloneSVG(svg);
    }
    /**
     * @protected
     * @param {?} str
     * @return {?}
     */
    _createSVGElementFromString(str) {
        /** @type {?} */
        const div = this._document.createElement('div');
        div.innerHTML = str;
        /** @type {?} */
        const svg = div.querySelector('svg');
        if (!svg) {
            throw SVGTagNotFoundError;
        }
        return svg;
    }
    /**
     * @protected
     * @param {?} svg
     * @return {?}
     */
    _setSVGAttribute(svg) {
        this._renderer.setAttribute(svg, 'width', '1em');
        this._renderer.setAttribute(svg, 'height', '1em');
        return svg;
    }
    /**
     * @protected
     * @param {?} svg
     * @param {?} twotone
     * @param {?} pri
     * @param {?} sec
     * @return {?}
     */
    _colorizeSVGIcon(svg, twotone, pri, sec) {
        if (twotone) {
            /** @type {?} */
            const children = svg.childNodes;
            /** @type {?} */
            const length = children.length;
            for (let i = 0; i < length; i++) {
                /** @type {?} */
                const child = (/** @type {?} */ (children[i]));
                if (child.getAttribute('fill') === 'secondaryColor') {
                    this._renderer.setAttribute(child, 'fill', sec);
                }
                else {
                    this._renderer.setAttribute(child, 'fill', pri);
                }
            }
        }
        this._renderer.setAttribute(svg, 'fill', 'currentColor');
        return svg;
    }
}
/** @nocollapse */
IconService.ctorParameters = () => [
    { type: RendererFactory2 },
    { type: HttpBackend, decorators: [{ type: Optional }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: DomSanitizer }
];
if (false) {
    /** @type {?} */
    IconService.prototype.defaultTheme;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._renderer;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._http;
    /**
     * All icon definitions would be registered here.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgDefinitions;
    /**
     * Cache all rendered icons. Icons are identified by name, theme,
     * and for twotone icons, primary color and secondary color.
     * @type {?}
     * @protected
     */
    IconService.prototype._svgRenderedDefinitions;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._inProgressFetches;
    /**
     * Url prefix for fetching inline SVG by dynamic importing.
     * @type {?}
     * @protected
     */
    IconService.prototype._assetsUrlRoot;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._twoToneColorPalette;
    /**
     * Record if a handler is registered.
     * @type {?}
     * @private
     */
    IconService.prototype._enableJsonpLoading;
    /**
     * @type {?}
     * @private
     */
    IconService.prototype._jsonpIconLoad$;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._rendererFactory;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._handler;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype._document;
    /**
     * @type {?}
     * @protected
     */
    IconService.prototype.sanitizer;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFudC1kZXNpZ24vaWNvbnMtYW5ndWxhci8iLCJzb3VyY2VzIjpbImNvbXBvbmVudC9pY29uLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBQy9ELE9BQU8sRUFDTCxNQUFNLEVBQ04sUUFBUSxFQUVSLGdCQUFnQixFQUNoQixlQUFlLEVBQ2hCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsRUFBRSxJQUFJLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3ZELE9BQU8sRUFDTCxVQUFVLEVBQ1YsTUFBTSxFQUNOLFFBQVEsRUFDUixHQUFHLEVBQ0gsS0FBSyxFQUNMLElBQUksRUFDSixHQUFHLEVBQ0osTUFBTSxnQkFBZ0IsQ0FBQztBQVF4QixPQUFPLEVBQ0wsUUFBUSxFQUNSLHlCQUF5QixFQUN6QixtQkFBbUIsRUFDbkIsaUJBQWlCLEVBQ2pCLFlBQVksRUFDWixnQkFBZ0IsRUFDaEIsZ0JBQWdCLEVBQ2hCLElBQUksRUFDSixVQUFVLEVBQ1Ysa0JBQWtCLEVBQ25CLE1BQU0sVUFBVSxDQUFDO0FBQ2xCLE9BQU8sRUFDTCwwQkFBMEIsRUFDMUIsbUJBQW1CLEVBQ25CLGlCQUFpQixFQUNqQiwwQkFBMEIsRUFDMUIsbUJBQW1CLEVBQ25CLGVBQWUsRUFDaEIsTUFBTSxjQUFjLENBQUM7O01BRWhCLGtCQUFrQixHQUFHLGlCQUFpQjtBQUU1QyxNQUFNLE9BQU8sV0FBVzs7Ozs7OztJQW1EdEIsWUFDWSxnQkFBa0MsRUFDdEIsUUFBcUIsRUFFSCxTQUFjLEVBQzVDLFNBQXVC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cG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEh0dHBCYWNrZW5kLCBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHtcbiAgSW5qZWN0LFxuICBPcHRpb25hbCxcbiAgUmVuZGVyZXIyLFxuICBSZW5kZXJlckZhY3RvcnkyLFxuICBTZWN1cml0eUNvbnRleHRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEb21TYW5pdGl6ZXIgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IG9mIGFzIHJ4b2YsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGZpbHRlcixcbiAgZmluYWxpemUsXG4gIG1hcCxcbiAgc2hhcmUsXG4gIHRha2UsXG4gIHRhcFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBDYWNoZWRJY29uRGVmaW5pdGlvbixcbiAgSWNvbkRlZmluaXRpb24sXG4gIFRoZW1lVHlwZSxcbiAgVHdvVG9uZUNvbG9yUGFsZXR0ZSxcbiAgVHdvVG9uZUNvbG9yUGFsZXR0ZVNldHRlclxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQge1xuICBjbG9uZVNWRyxcbiAgZ2V0SWNvbkRlZmluaXRpb25Gcm9tQWJicixcbiAgZ2V0TmFtZUFuZE5hbWVzcGFjZSxcbiAgZ2V0U2Vjb25kYXJ5Q29sb3IsXG4gIGhhc05hbWVzcGFjZSxcbiAgaXNJY29uRGVmaW5pdGlvbixcbiAgcmVwbGFjZUZpbGxDb2xvcixcbiAgd2FybixcbiAgd2l0aFN1ZmZpeCxcbiAgd2l0aFN1ZmZpeEFuZENvbG9yXG59IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCB7XG4gIER5bmFtaWNMb2FkaW5nVGltZW91dEVycm9yLFxuICBIdHRwTW9kdWxlTm90SW1wb3J0LFxuICBJY29uTm90Rm91bmRFcnJvcixcbiAgTmFtZVNwYWNlSXNOb3RTcGVjaWZ5RXJyb3IsXG4gIFNWR1RhZ05vdEZvdW5kRXJyb3IsXG4gIFVybE5vdFNhZmVFcnJvclxufSBmcm9tICcuL2ljb24uZXJyb3InO1xuXG5jb25zdCBKU09OUF9IQU5ETEVSX05BTUUgPSAnX19hbnRfaWNvbl9sb2FkJztcblxuZXhwb3J0IGNsYXNzIEljb25TZXJ2aWNlIHtcbiAgZGVmYXVsdFRoZW1lOiBUaGVtZVR5cGUgPSAnb3V0bGluZSc7XG5cbiAgc2V0IHR3b1RvbmVDb2xvcih7XG4gICAgcHJpbWFyeUNvbG9yLFxuICAgIHNlY29uZGFyeUNvbG9yXG4gIH06IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIpIHtcbiAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnByaW1hcnlDb2xvciA9IHByaW1hcnlDb2xvcjtcbiAgICB0aGlzLl90d29Ub25lQ29sb3JQYWxldHRlLnNlY29uZGFyeUNvbG9yID1cbiAgICAgIHNlY29uZGFyeUNvbG9yIHx8IGdldFNlY29uZGFyeUNvbG9yKHByaW1hcnlDb2xvcik7XG4gIH1cblxuICBnZXQgdHdvVG9uZUNvbG9yKCk6IFR3b1RvbmVDb2xvclBhbGV0dGVTZXR0ZXIge1xuICAgIC8vIE1ha2UgYSBjb3B5IHRvIGF2b2lkIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgICByZXR1cm4geyAuLi50aGlzLl90d29Ub25lQ29sb3JQYWxldHRlIH0gYXMgVHdvVG9uZUNvbG9yUGFsZXR0ZTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfcmVuZGVyZXI6IFJlbmRlcmVyMjtcbiAgcHJvdGVjdGVkIF9odHRwOiBIdHRwQ2xpZW50O1xuXG4gIC8qKlxuICAgKiBBbGwgaWNvbiBkZWZpbml0aW9ucyB3b3VsZCBiZSByZWdpc3RlcmVkIGhlcmUuXG4gICAqL1xuICBwcm90ZWN0ZWQgX3N2Z0RlZmluaXRpb25zID0gbmV3IE1hcDxzdHJpbmcsIEljb25EZWZpbml0aW9uPigpO1xuXG4gIC8qKlxuICAgKiBDYWNoZSBhbGwgcmVuZGVyZWQgaWNvbnMuIEljb25zIGFyZSBpZGVudGlmaWVkIGJ5IG5hbWUsIHRoZW1lLFxuICAgKiBhbmQgZm9yIHR3b3RvbmUgaWNvbnMsIHByaW1hcnkgY29sb3IgYW5kIHNlY29uZGFyeSBjb2xvci5cbiAgICovXG4gIHByb3RlY3RlZCBfc3ZnUmVuZGVyZWREZWZpbml0aW9ucyA9IG5ldyBNYXA8c3RyaW5nLCBDYWNoZWRJY29uRGVmaW5pdGlvbj4oKTtcblxuICBwcm90ZWN0ZWQgX2luUHJvZ3Jlc3NGZXRjaGVzID0gbmV3IE1hcDxcbiAgICBzdHJpbmcsXG4gICAgT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+XG4gID4oKTtcblxuICAvKipcbiAgICogVXJsIHByZWZpeCBmb3IgZmV0Y2hpbmcgaW5saW5lIFNWRyBieSBkeW5hbWljIGltcG9ydGluZy5cbiAgICovXG4gIHByb3RlY3RlZCBfYXNzZXRzVXJsUm9vdCA9ICcnO1xuXG4gIHByb3RlY3RlZCBfdHdvVG9uZUNvbG9yUGFsZXR0ZTogVHdvVG9uZUNvbG9yUGFsZXR0ZSA9IHtcbiAgICBwcmltYXJ5Q29sb3I6ICcjMzMzMzMzJyxcbiAgICBzZWNvbmRhcnlDb2xvcjogJyNFNkU2RTYnXG4gIH07XG5cbiAgLyoqIFJlY29yZCBpZiBhIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZC4gKi9cbiAgcHJpdmF0ZSBfZW5hYmxlSnNvbnBMb2FkaW5nID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSBfanNvbnBJY29uTG9hZCQgPSBuZXcgU3ViamVjdDxJY29uRGVmaW5pdGlvbj4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcm90ZWN0ZWQgX3JlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MixcbiAgICBAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgX2hhbmRsZXI6IEh0dHBCYWNrZW5kLFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KERPQ1VNRU5UKSBwcm90ZWN0ZWQgX2RvY3VtZW50OiBhbnksXG4gICAgcHJvdGVjdGVkIHNhbml0aXplcjogRG9tU2FuaXRpemVyXG4gICkge1xuICAgIHRoaXMuX3JlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJGYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKG51bGwsIG51bGwpO1xuICAgIGlmICh0aGlzLl9oYW5kbGVyKSB7XG4gICAgICB0aGlzLl9odHRwID0gbmV3IEh0dHBDbGllbnQodGhpcy5faGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgdG8gc3dpdGNoIHRvIGpzb25wIGxpa2UgbG9hZGluZy5cbiAgICovXG4gIHVzZUpzb25wTG9hZGluZygpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuX2VuYWJsZUpzb25wTG9hZGluZykge1xuICAgICAgdGhpcy5fZW5hYmxlSnNvbnBMb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgd2luZG93W0pTT05QX0hBTkRMRVJfTkFNRV0gPSAoaWNvbjogSWNvbkRlZmluaXRpb24pID0+IHtcbiAgICAgICAgdGhpcy5fanNvbnBJY29uTG9hZCQubmV4dChpY29uKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm4oJ1lvdSBhcmUgYWxyZWFkeSB1c2luZyBqc29ucCBsb2FkaW5nLicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2UgdGhlIHByZWZpeCBvZiB0aGUgaW5saW5lIHN2ZyByZXNvdXJjZXMsIHNvIHRoZXkgY291bGQgYmUgZGVwbG95ZWQgZWxzZXdoZXJlLCBsaWtlIENETi5cbiAgICogQHBhcmFtIHByZWZpeFxuICAgKi9cbiAgY2hhbmdlQXNzZXRzU291cmNlKHByZWZpeDogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5fYXNzZXRzVXJsUm9vdCA9IHByZWZpeC5lbmRzV2l0aCgnLycpID8gcHJlZml4IDogcHJlZml4ICsgJy8nO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBpY29ucyBwcm92aWRlZCBieSBhbnQgZGVzaWduLlxuICAgKiBAcGFyYW0gaWNvbnNcbiAgICovXG4gIGFkZEljb24oLi4uaWNvbnM6IEljb25EZWZpbml0aW9uW10pOiB2b2lkIHtcbiAgICBpY29ucy5mb3JFYWNoKGljb24gPT4ge1xuICAgICAgdGhpcy5fc3ZnRGVmaW5pdGlvbnMuc2V0KHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKSwgaWNvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gaWNvbi4gTmFtZXNwYWNlIGlzIHJlcXVpcmVkLlxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcGFyYW0gbGl0ZXJhbFxuICAgKi9cbiAgYWRkSWNvbkxpdGVyYWwodHlwZTogc3RyaW5nLCBsaXRlcmFsOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBbbmFtZSwgbmFtZXNwYWNlXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG4gICAgaWYgKCFuYW1lc3BhY2UpIHtcbiAgICAgIHRocm93IE5hbWVTcGFjZUlzTm90U3BlY2lmeUVycm9yKCk7XG4gICAgfVxuICAgIHRoaXMuYWRkSWNvbih7IG5hbWU6IHR5cGUsIGljb246IGxpdGVyYWwgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBjYWNoZS5cbiAgICovXG4gIGNsZWFyKCk6IHZvaWQge1xuICAgIHRoaXMuX3N2Z0RlZmluaXRpb25zLmNsZWFyKCk7XG4gICAgdGhpcy5fc3ZnUmVuZGVyZWREZWZpbml0aW9ucy5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlbmRlcmVkIGBTVkdFbGVtZW50YC5cbiAgICogQHBhcmFtIGljb25cbiAgICogQHBhcmFtIHR3b1RvbmVDb2xvclxuICAgKi9cbiAgZ2V0UmVuZGVyZWRDb250ZW50KFxuICAgIGljb246IEljb25EZWZpbml0aW9uIHwgc3RyaW5nLFxuICAgIHR3b1RvbmVDb2xvcj86IHN0cmluZ1xuICApOiBPYnNlcnZhYmxlPFNWR0VsZW1lbnQ+IHtcbiAgICAvLyBJZiBgaWNvbmAgaXMgYSBgSWNvbkRlZmluaXRpb25gLCBnbyB0byB0aGUgbmV4dCBzdGVwLiBJZiBub3QsIHRyeSB0byBmZXRjaCBpdCBmcm9tIGNhY2hlLlxuICAgIGNvbnN0IGRlZmluaXRpb25Pck51bGw6IEljb25EZWZpbml0aW9uIHwgbnVsbCA9IGlzSWNvbkRlZmluaXRpb24oaWNvbilcbiAgICAgID8gKGljb24gYXMgSWNvbkRlZmluaXRpb24pXG4gICAgICA6IHRoaXMuX3N2Z0RlZmluaXRpb25zLmdldChpY29uKSB8fCBudWxsO1xuXG4gICAgLy8gSWYgYGljb25gIGlzIGEgYEljb25EZWZpbml0aW9uYCBvZiBzdWNjZXNzZnVsbHkgZmV0Y2gsIHdyYXAgaXQgaW4gYW4gYE9ic2VydmFibGVgLlxuICAgIC8vIE90aGVyd2lzZSB0cnkgdG8gZmV0Y2ggaXQgZnJvbSByZW1vdGUuXG4gICAgY29uc3QgJGljb25EZWZpbml0aW9uID0gZGVmaW5pdGlvbk9yTnVsbFxuICAgICAgPyByeG9mKGRlZmluaXRpb25Pck51bGwpXG4gICAgICA6IHRoaXMuX2xvYWRJY29uRHluYW1pY2FsbHkoaWNvbiBhcyBzdHJpbmcpO1xuXG4gICAgLy8gSWYgZmluYWxseSBnZXQgYW4gYEljb25EZWZpbml0aW9uYCwgcmVuZGVyIGFuZCByZXR1cm4gaXQuIE90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICByZXR1cm4gJGljb25EZWZpbml0aW9uLnBpcGUoXG4gICAgICBtYXAoaSA9PiB7XG4gICAgICAgIGlmICghaSkge1xuICAgICAgICAgIHRocm93IEljb25Ob3RGb3VuZEVycm9yKGljb24gYXMgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KGksIHR3b1RvbmVDb2xvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICBnZXRDYWNoZWRJY29ucygpOiBNYXA8c3RyaW5nLCBJY29uRGVmaW5pdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLl9zdmdEZWZpbml0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcmF3IHN2ZyBhbmQgYXNzZW1ibGUgYSBgSWNvbkRlZmluaXRpb25gIG9iamVjdC5cbiAgICogQHBhcmFtIHR5cGVcbiAgICovXG4gIHByb3RlY3RlZCBfbG9hZEljb25EeW5hbWljYWxseShcbiAgICB0eXBlOiBzdHJpbmdcbiAgKTogT2JzZXJ2YWJsZTxJY29uRGVmaW5pdGlvbiB8IG51bGw+IHtcbiAgICAvLyBJZiBkZXZlbG9wZXIgZG9lc24ndCBwcm92aWRlIEhUVFAgbW9kdWxlIG5vciBlbmFibGUganNvbnAgbG9hZGluZywganVzdCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAoIXRoaXMuX2h0dHAgJiYgIXRoaXMuX2VuYWJsZUpzb25wTG9hZGluZykge1xuICAgICAgcmV0dXJuIHJ4b2YoSHR0cE1vZHVsZU5vdEltcG9ydCgpKTtcbiAgICB9XG5cbiAgICAvLyBJZiBtdWx0aSBkaXJlY3RpdmUgYXNrIGZvciB0aGUgc2FtZSBpY29uIGF0IHRoZSBzYW1lIHRpbWUsXG4gICAgLy8gcmVxdWVzdCBzaG91bGQgb25seSBiZSBmaXJlZCBvbmNlLlxuICAgIGxldCBpblByb2dyZXNzID0gdGhpcy5faW5Qcm9ncmVzc0ZldGNoZXMuZ2V0KHR5cGUpO1xuXG4gICAgaWYgKCFpblByb2dyZXNzKSB7XG4gICAgICBjb25zdCBbbmFtZSwgbmFtZXNwYWNlXSA9IGdldE5hbWVBbmROYW1lc3BhY2UodHlwZSk7XG5cbiAgICAgIC8vIElmIHRoZSBzdHJpbmcgaGFzIGEgbmFtZXNwYWNlIHdpdGhpbiwgY3JlYXRlIGEgc2ltcGxlIGBJY29uRGVmaW5pdGlvbmAuXG4gICAgICBjb25zdCBpY29uOiBJY29uRGVmaW5pdGlvbiA9IG5hbWVzcGFjZVxuICAgICAgICA/IHsgbmFtZTogdHlwZSwgaWNvbjogJycgfVxuICAgICAgICA6IGdldEljb25EZWZpbml0aW9uRnJvbUFiYnIobmFtZSk7XG5cbiAgICAgIGNvbnN0IHN1ZmZpeCA9IHRoaXMudXNlSnNvbnBMb2FkaW5nID8gJy5qcycgOiAnLnN2Zyc7XG4gICAgICBjb25zdCB1cmwgPVxuICAgICAgICAobmFtZXNwYWNlXG4gICAgICAgICAgPyBgJHt0aGlzLl9hc3NldHNVcmxSb290fWFzc2V0cy8ke25hbWVzcGFjZX0vJHtuYW1lfWBcbiAgICAgICAgICA6IGAke3RoaXMuX2Fzc2V0c1VybFJvb3R9YXNzZXRzLyR7aWNvbi50aGVtZX0vJHtpY29uLm5hbWV9YCkgKyBzdWZmaXg7XG5cbiAgICAgIGNvbnN0IHNhZmVVcmwgPSB0aGlzLnNhbml0aXplci5zYW5pdGl6ZShTZWN1cml0eUNvbnRleHQuVVJMLCB1cmwpO1xuXG4gICAgICBpZiAoIXNhZmVVcmwpIHtcbiAgICAgICAgdGhyb3cgVXJsTm90U2FmZUVycm9yKHVybCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICF0aGlzLl9lbmFibGVKc29ucExvYWRpbmdcbiAgICAgICAgPyB0aGlzLl9odHRwXG4gICAgICAgICAgICAuZ2V0KHNhZmVVcmwsIHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfSlcbiAgICAgICAgICAgIC5waXBlKG1hcChsaXRlcmFsID0+ICh7IC4uLmljb24sIGljb246IGxpdGVyYWwgfSkpKVxuICAgICAgICA6IHRoaXMuX2xvYWRJY29uRHluYW1pY2FsbHlXaXRoSnNvbnAoaWNvbiwgc2FmZVVybCk7XG5cbiAgICAgIGluUHJvZ3Jlc3MgPSBzb3VyY2UucGlwZShcbiAgICAgICAgdGFwKGRlZmluaXRpb24gPT4gdGhpcy5hZGRJY29uKGRlZmluaXRpb24pKSxcbiAgICAgICAgZmluYWxpemUoKCkgPT4gdGhpcy5faW5Qcm9ncmVzc0ZldGNoZXMuZGVsZXRlKHR5cGUpKSxcbiAgICAgICAgY2F0Y2hFcnJvcigoKSA9PiByeG9mKG51bGwpKSxcbiAgICAgICAgc2hhcmUoKVxuICAgICAgKTtcblxuICAgICAgdGhpcy5faW5Qcm9ncmVzc0ZldGNoZXMuc2V0KHR5cGUsIGluUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHJldHVybiBpblByb2dyZXNzO1xuICB9XG5cbiAgcHJvdGVjdGVkIF9sb2FkSWNvbkR5bmFtaWNhbGx5V2l0aEpzb25wKGljb246IEljb25EZWZpbml0aW9uLCB1cmw6IHN0cmluZyk6IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGU8SWNvbkRlZmluaXRpb24+KHN1YnNjcmliZXIgPT4ge1xuICAgICAgY29uc3QgbG9hZGVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjbGVhbigpO1xuICAgICAgICBzdWJzY3JpYmVyLmVycm9yKER5bmFtaWNMb2FkaW5nVGltZW91dEVycm9yKCkpO1xuICAgICAgfSwgNjAwMCk7XG5cbiAgICAgIGxvYWRlci5zcmMgPSB1cmw7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFuKCk6IHZvaWQge1xuICAgICAgICBsb2FkZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsb2FkZXIpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxvYWRlcik7XG4gICAgICB0aGlzLl9qc29ucEljb25Mb2FkJFxuICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICBmaWx0ZXIoaSA9PiBpLm5hbWUgPT09IGljb24ubmFtZSAmJiBpLnRoZW1lID09PSBpY29uLnRoZW1lKSxcbiAgICAgICAgICAgICAgdGFrZSgxKVxuICAgICAgICAgIClcbiAgICAgICAgICAuc3Vic2NyaWJlKGkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5uZXh0KGkpO1xuICAgICAgICAgICAgY2xlYW4oKTtcbiAgICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYSBuZXcgYFNWR0VsZW1lbnRgIGZvciBhIGdpdmVuIGBJY29uRGVmaW5pdGlvbmAsIG9yIG1ha2UgYSBjb3B5IGZyb20gY2FjaGUuXG4gICAqIEBwYXJhbSBpY29uXG4gICAqIEBwYXJhbSB0d29Ub25lQ29sb3JcbiAgICovXG4gIHByb3RlY3RlZCBfbG9hZFNWR0Zyb21DYWNoZU9yQ3JlYXRlTmV3KFxuICAgIGljb246IEljb25EZWZpbml0aW9uLFxuICAgIHR3b1RvbmVDb2xvcj86IHN0cmluZ1xuICApOiBTVkdFbGVtZW50IHtcbiAgICBsZXQgc3ZnOiBTVkdFbGVtZW50O1xuXG4gICAgY29uc3QgcHJpID0gdHdvVG9uZUNvbG9yIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUucHJpbWFyeUNvbG9yO1xuICAgIGNvbnN0IHNlYyA9XG4gICAgICBnZXRTZWNvbmRhcnlDb2xvcihwcmkpIHx8IHRoaXMuX3R3b1RvbmVDb2xvclBhbGV0dGUuc2Vjb25kYXJ5Q29sb3I7XG4gICAgY29uc3Qga2V5ID1cbiAgICAgIGljb24udGhlbWUgPT09ICd0d290b25lJ1xuICAgICAgICA/IHdpdGhTdWZmaXhBbmRDb2xvcihpY29uLm5hbWUsIGljb24udGhlbWUsIHByaSwgc2VjKVxuICAgICAgICA6IGljb24udGhlbWUgPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGljb24ubmFtZVxuICAgICAgICA6IHdpdGhTdWZmaXgoaWNvbi5uYW1lLCBpY29uLnRoZW1lKTtcblxuICAgIC8vIFRyeSB0byBtYWtlIGEgY29weSBmcm9tIGNhY2hlLlxuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX3N2Z1JlbmRlcmVkRGVmaW5pdGlvbnMuZ2V0KGtleSk7XG5cbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICBzdmcgPSBjYWNoZWQuaWNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3ZnID0gdGhpcy5fc2V0U1ZHQXR0cmlidXRlKFxuICAgICAgICB0aGlzLl9jb2xvcml6ZVNWR0ljb24oXG4gICAgICAgICAgLy8gSWNvbnMgcHJvdmlkZWQgYnkgYW50IGRlc2lnbiBzaG91bGQgYmUgcmVmaW5lZCB0byByZW1vdmUgcHJlc2V0IGNvbG9ycy5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVTVkdFbGVtZW50RnJvbVN0cmluZyhcbiAgICAgICAgICAgIGhhc05hbWVzcGFjZShpY29uLm5hbWUpID8gaWNvbi5pY29uIDogcmVwbGFjZUZpbGxDb2xvcihpY29uLmljb24pXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpY29uLnRoZW1lID09PSAndHdvdG9uZScsXG4gICAgICAgICAgcHJpLFxuICAgICAgICAgIHNlY1xuICAgICAgICApXG4gICAgICApO1xuICAgICAgLy8gQ2FjaGUgaXQuXG4gICAgICB0aGlzLl9zdmdSZW5kZXJlZERlZmluaXRpb25zLnNldChrZXksIHtcbiAgICAgICAgLi4uaWNvbixcbiAgICAgICAgaWNvbjogc3ZnXG4gICAgICB9IGFzIENhY2hlZEljb25EZWZpbml0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2xvbmVTVkcoc3ZnKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfY3JlYXRlU1ZHRWxlbWVudEZyb21TdHJpbmcoc3RyOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuaW5uZXJIVE1MID0gc3RyO1xuICAgIGNvbnN0IHN2ZzogU1ZHRWxlbWVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKTtcbiAgICBpZiAoIXN2Zykge1xuICAgICAgdGhyb3cgU1ZHVGFnTm90Rm91bmRFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuXG4gIHByb3RlY3RlZCBfc2V0U1ZHQXR0cmlidXRlKHN2ZzogU1ZHRWxlbWVudCk6IFNWR0VsZW1lbnQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICd3aWR0aCcsICcxZW0nKTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoc3ZnLCAnaGVpZ2h0JywgJzFlbScpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cblxuICBwcm90ZWN0ZWQgX2NvbG9yaXplU1ZHSWNvbihcbiAgICBzdmc6IFNWR0VsZW1lbnQsXG4gICAgdHdvdG9uZTogYm9vbGVhbixcbiAgICBwcmk6IHN0cmluZyxcbiAgICBzZWM6IHN0cmluZ1xuICApOiBTVkdFbGVtZW50IHtcbiAgICBpZiAodHdvdG9uZSkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBzdmcuY2hpbGROb2RlcztcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQ6IEhUTUxFbGVtZW50ID0gY2hpbGRyZW5baV0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlmIChjaGlsZC5nZXRBdHRyaWJ1dGUoJ2ZpbGwnKSA9PT0gJ3NlY29uZGFyeUNvbG9yJykge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShjaGlsZCwgJ2ZpbGwnLCBzZWMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShjaGlsZCwgJ2ZpbGwnLCBwcmkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShzdmcsICdmaWxsJywgJ2N1cnJlbnRDb2xvcicpO1xuICAgIHJldHVybiBzdmc7XG4gIH1cbn1cbiJdfQ==